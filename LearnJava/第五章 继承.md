# 第五章 继承



## 5.1 父类（超类）、子类



```java
public class Manager extends Employee{
    private double bonus;
    
    public void setBonus(double bonus){
        this.bonus = bonus;
    }
}
```

```java
//wrong
public class Manager extends Employee{
    public double getSalary(){
        return salary + bonus;
    }
}
```

Manager 类的 getSalary 方法**不能够直接地访问超类的私有域**，尽管每个 Manager 对象都有一个 salary 的域。如果要访问**需要借助公有接口**，如 Employee 类中的公有方法：

```java
public class Manager extends Employee{
    public double getSalary(){
        double baseSalary = super.getSalary();//OK
        return baseSalary + bonus;
    }
}
```



`super.getSalary()`调用了 Employee 类中的 getSalary 方法。



### 5.1.3 子类构造器

由于 Manager 类的构造器也不能访问 Employee 类的私有域，所以必须利用 Employee 类的构造器对这部分私有预进行初始化，这必须是子类构造器的第一条语句：

```java
public Manager(asdklf,jadfkla){//子类构造器
    super(name, salary,asdf);//子类构造器的第一条语句
    bonus = 0;
}
```



### 5.1.5 多态





一个用来判断是否应该设计为继承关系的规则：**"is-a"** 规则：子类的每个对象也是超类的对象。其另一种表述法是**置换规则**：程序中出现超类对象的任何地方都可以用子类对象置换。

Java中，对象变量是**多态**的。一个 Employee 变量既可以引用一个 Employee 类对象，也可以引用一个 Employee 类的任何一个子类的对象，但不能将一个超类的引用赋给子类变量。

```java
Manager boss = new Manager(...);
Employee[] staff = new Employee[3];
staff[0] = boss;
Manager m = staff[1];//Err

boss.setBonus(500);//OK
staff.setBonus(40);//Err
```

因为`staff[0]`**声明的**类型是 Employee，而 setBonus 不是 Employee 类的方法。



**Warning**：在覆盖一个方法时，子类方法不能低于超类方法的可见性。



### 5.1.10 受保护访问



Java 用于控制可见性的 4 个访问修饰符：

1. private——仅对本类可见
2. public——对所有类可见
3. protected——对本包和所有**子类**可见
4. 默认——对本包可见



### 5.2.3 hashCode 方法



*待编辑*



























